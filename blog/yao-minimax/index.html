<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<meta name="author" content="Trey Manuszak">
	<meta name="description" content="A blog written by Trey Manuszak
							containing his ramblings about many topics incuding, but not limited to: 
							cryptography, math, cryptocurrency, security, and travel.">
	<meta name="keywords" content="blog, cryptography, math, cryptocurrency,
							security, travel.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="/assets/favicon/reutersvards-triangle-32px.png" type="image/png">
	<title>BLOG || Trey Manuszak</title>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script type="text/javascript" id="MathJax-script" async
  	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>
	<style>
		@font-face {
			font-family: 'Source Serif Pro';
			src: url('/assets/fonts/SourceSerifPro-Regular.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Source Serif Pro SemiBold';
			src: url('/assets/fonts/SourceSerifPro-SemiBold.ttf') format('truetype'); 
		}
		body {
			font-family: 'Source Serif Pro', serif;
			background-color: black;
			color: white;
			margin-left: auto;
			margin-right: auto;
			margin-top: 30px;
			margin-bottom: 50px;
			padding: 0 30px;
			max-width: 1120px;
		}
		header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			text-align: center;
		}
		footer {
			display: flex;
			align-items: center;
			justify-content: center;
			margin: 1.5em;
			font-size: 1.5em;
		}
		h1 {
			font-family: 'Source Serif Pro SemiBold', serif;
			display: inline-block;
			font-variant: small-caps;
			margin: auto;
		}
		h2 {
			font-family: 'Source Serif Pro SemiBold', serif;
			display: inline-block;
			font-variant: small-caps;
		}	
		hr {
			border: 0;
			height: 4px;
			margin-top: 10px;
			background-image: linear-gradient(to right, transparent, #FF8360, #E8E288, #7DCE82, transparent);
		}	
		b {
			font-family: 'Source Serif Pro SemiBold', serif;
			color: #7DCE82;
		}
		a {
			color: white;
		}
		b > a {
			font-family: 'Source Serif Pro SemiBold', serif;
			color: #7DCE82;
		}
		p {
			font-size: 1.2em;
		}	
		p.indent {
			text-indent: 30px;
		}
		.qed {
			color: #7DCE82;
			display: inline;
			margin: 0 0 0 auto;
		}
		.MathJax {
		
		}
		.date {
			display: inline-block;
			text-align: right;
			padding-right: 8px;
			border-bottom: 3px solid;
			border-right: 3px solid;
			border-image: linear-gradient(to top right, transparent, #FF8360, #E8E288, #7DCE82, transparent);
			border-image-slice: 1;
		}				
		.drawing {
			align-self: center;
			height: auto;
			width: 80%;
		}
		em.typewriter {
 			background-color: #292F36;
			color: #7DCE82;
			font-family: monospace;
			font-style: normal;
			border-radius: 2px;
			padding: 0 3px;
		}
		.figure-container {
			display: flex;
			justify-content: center;
		}
		.figure {
			display: flex;
			justify-content: center;
			align-content: center;
			flex-direction: column;
		}
		.theorem-container {
			display: flex;
			justify-content: center;
		}
		.theorem {
			padding: 20px 15px;
			display: flex;
			justify-content: center;
			align-content: center;
			flex-direction: column;
			border: 3px solid;
			border-image: linear-gradient(to bottom right, #FF8360, #E8E288, #7DCE82);
			border-image-slice: 1;
		}
		.theorem > p {
			margin: 0;
		}
		.left {
			border-left: 3px solid #7DCE82 !important;
		}
		.top {
			border-top: 3px solid #7DCE82 !important;
		}
		.right {
			border-right: 3px solid #7DCE82 !important;
		}
		.bottom {
			border-bottom: 3px solid #7DCE82 !important;
		}	
		.tg {
			border-collapse: collapse;
			border-spacing: 0;
			margin: auto;
		}
		.tg td {
			border-color: white;
			border-style: solid;
			border-width: 1px;
  		overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}
		.tg th {
			border-color: white;
			border-style: solid;
			border-width: 1px;
			overflow: hidden;
			padding: 10px 5px;
			word-break: normal;
		}
		.tg .tg-baqh {
			text-align: center;
			vertical-align: top
		}
		.tg .tg-c3ow {
			border-color: white;
			text-align: center;
			vertical-align: top
		}
		.tg .tg-sxqf {
			border-color:	white;
			font-family: inherit;
			text-align: left;
			vertical-align: top
		}
		.tg .tg-0pky {
			border-color: white;
			text-align: left;
			vertical-align: top
		}
		.tg .tg-0lax {
			text-align: left;
			vertical-align: top
		}
		.center {
			text-align: center !important; 
			vertical-align: middle !important;
		}
		#returnhome {
			display: inline-block;
			text-decoration: none;
		}
		#returnimg {
			height: 100px;
			width: 100px;
		}
		@media screen and (max-width: 600px) {
			h1 {
				font-size: 1.5em;
			}
		}
		@media screen and (min-width: 601px) {
			.figure {
				max-width: 70%;
			}
			.theorem {
				max-width: 70%;
			}
		}
	</style>
</head>

<body>
	<header>
		<a id="returnhome" href="/blog/index.html">
			<img id="returnimg" src="/assets/reutersvards-triangle-100px.png"/>
			<h4 style="font-variant: small-caps; margin: 0;">Back</h4>
		</a>
		<h1>Game Theory and its Influence on Randomized Algorithms</h1>
	</header>
	<hr>
	<span class="date">12-14-22</span>
	<article>
		<p class="indent">
			In my last semester of graduate school, I attended a 
			“<a href="https://en.wikipedia.org/wiki/Randomized_algorithm">Randomized</a> 
			and <a href="https://en.wikipedia.org/wiki/Approximation_algorithm">Approximation</a> 
			Algorithms” course. It was by far the most rigorous course in my graduate studies 
			and reminded me a great deal of the difficulty of my courses I took during 
			my undergrad in Mathematics. There was one particular topic in the randomized 
			algorithms section that stood out as fascinating and profound. <b>There 
			is only one known method of lower bounding the expected performance of 
			randomized algorithms and it comes from famous results in 
			<a href="https://en.wikipedia.org/wiki/Game_theory">game theory</a>.</b> 
			This particular section did not come easy to me as I had no experience with game theory. 
			In fact, the whole course was an uphill battle as I had not done any of the three 
			required prerequisites that are “Combinatorial Algorithms”, “Foundations of Algorithms”, 
			and “Theory of Computation”. Most of the class relied HEAVILY on statistics, which I 
			had not formally taken either. I saw the course as a final boss battle to test my limits. 
			Anyway, I wanted to break down this interesting topic as I grappled with it as someone who 
			tried to learn it with little foundational experience.
		</p>
		<h2>Game Theory Basics</h2>
		<p class="indent">
			Game theory provides a formal language for the representation and analysis 
			of situations where several entities take rational actions that affect each other 
			[Bonanno, 2018]. Imagine a game of rock, paper, scissors with the standard rules 
			between two players, Robert and Charles. We can represent this game from the 
			perspective of Robert as what is called a payoff matrix. Each row of the matrix 
			represents a strategy available to Robert and each column represents a strategy 
			available to Charles. For our payoff matrix \(P\), which we can find in <b>Figure 1</b>, 
			the component \(P_{i,j}\) represents the amount that Charles pays to Robert when 
			Robert chooses strategy \(i\) and Charles chooses strategy \(j\). 
		</p>
		<div class="figure-container">
			<div class="figure">
				<table class="tg">
				<tbody>
					<tr>
						<td class="tg-sxqf" style="border: none;"></td>
						<td class="tg-c3ow" style="border: none"></td>
						<td class="tg-c3ow" colspan="3">Charles</td>
					</tr>
					<tr>
						<td class="tg-0pky" style="border: none;"></td>
						<td class="tg-c3ow" style="border: none"></td>
						<td class="tg-c3ow bottom">Scissors</td>
						<td class="tg-c3ow bottom">Paper</td>
						<td class="tg-baqh bottom">Rock</td>
					</tr>
					<tr>
						<td class="tg-0pky" rowspan="3" style="transform: rotate(270deg) translate(0px, 40px);">Robert</td>
						<td class="tg-0pky right">Scissors</td>
						<td class="tg-c3ow top left">\(0\)</td>
						<td class="tg-c3ow top">\(1\)</td>
						<td class="tg-baqh top right">\(-1\)</td>
					</tr>
					<tr>
						<td class="tg-0pky right">Paper</td>
						<td class="tg-c3ow left">\(-1\)</td>
						<td class="tg-c3ow">\(0\)</td>
						<td class="tg-baqh right">\(1\)</td>
					</tr>
					<tr>
						<td class="tg-0lax right">Rock</td>
						<td class="tg-baqh bottom left">\(1\)</td>
						<td class="tg-baqh bottom">\(-1\)</td>
						<td class="tg-baqh bottom right">\(0\)</td>
					</tr>
				</tbody>
				</table>
				<p>
					<b>Figure 1</b>: Payoff matrix for normal rock, paper, scissors game.
					Robert's strategies are the rows and Charles strategies are the columns.
				</p>
			</div>
		</div>
		<p class="indent">
			This is an example of what is called a <em>two-person zero-sum game</em>. 
			That is, the net amount won by Robert and Charles is exactly zero. 
		</p>
		<p class="indent">
			Now, notice that Robert, the row player, wants to maximize the payoff, 
			while Charles, the column player, wants to minimize the payoff. If 
			neither player has information about what the opposing player wants to play, 
			and Robert chooses strategy \(i\), then he is guaranteed to win at least the 
			smallest payoff in row \(i\), no matter what Charles chooses. Similarly, if 
			Charles chooses strategy \(j\), then he is guaranteed to win at most the 
			largest payoff in column \(j\), no matter what Robert’s strategy is. Since 
			Robert wants to maximize the payoff, an optimal strategy for Robert, we denote 
			\(\mathcal{O}_R\), is to choose the strategy \(i\) that maximizes \(\min_j P_{i,j}\). 
			Similarly, since Charles wants to minimize the payoff, an optimal strategy for 
			Charles, we denote \(\mathcal{O}_C\), is to choose the strategy \(j\) that 
			minimizes \(\max_i P_{i,j}\).
		</p>
		<p class="indent">
			In simpler terms, each player is choosing the strategy that satisfies their 
			respective statement from the following:
		</p>
		<ul>
			<li>
				<p>Robert: For each row, find the smallest payoff. Choose the strategy 
				that is the largest of these.</p>
			</li>
			<li>
				<p>Charles: For each column, find the largest payoff. Choose the strategy 
				that is the smallest of these.</p>
			</li>
		</ul>
		<p class="indent">
			The strategy chosen will be their optimal strategy. For <b>Figure 1</b>, we have 
			\(\mathcal{O} _R = -1\) and \(\mathcal{O}_C = 1\). When these two are equal, the 
			game is said to have a solution and the value of the game is 
			\(V = \mathcal{O}_R = \mathcal{O}_C\). 
		</p>
		<p class="indent">
			Now, let’s change up the payoff matrix. Say we are playing rock, paper, scissors, 
			where the payoff is denoted in <b>Figure 2</b>. In <span style="color: #FF8360;">red</span>, 
			I have highlighted the 
			smallest payoff in each row. Robert chooses the largest of these, which is 
			underlined in his strategies. I have highlighted <span style="color: #E8E288">yellow</span> 
			in each column the 
			largest payoff. Charles will choose the strategy with the smallest of these values, 
			which is underlined in his strategies as well. Notice that now, this game has a 
			solution of \(V = 1\). It isn’t a very fun game for Charles, since the 
			best he can do is always pay Robert $1, but it is the best option if forced to play.
			Neither player has any incentive to deviate from their strategy.
		</p>
		<div class="figure-container">
			<div class="figure">
				<table class="tg">
				<tbody>
					<tr>
						<td class="tg-sxqf" style="border: none;"></td>
						<td class="tg-c3ow" style="border: none"></td>
						<td class="tg-c3ow" colspan="3">Charles</td>
					</tr>
					<tr>
						<td class="tg-0pky" style="border: none;"></td>
						<td class="tg-c3ow" style="border: none"></td>
						<td class="tg-c3ow bottom"i style="text-decoration: underline">Scissors</td>
						<td class="tg-c3ow bottom">Paper</td>
						<td class="tg-baqh bottom">Rock</td>
					</tr>
					<tr>
						<td class="tg-0pky" rowspan="3" style="transform: rotate(270deg) translate(0px, 40px);">Robert</td>
						<td class="tg-0pky right" style="text-decoration: underline">Scissors</td>
						<td class="tg-c3ow left top" style="background: linear-gradient(90deg, #FF8360, #E8E288)">\(1\)</td>
						<td class="tg-c3ow top" style="background: #E8E288">\(2\)</td>
						<td class="tg-baqh top right" style="background: #E8E288">\(3\)</td>
					</tr>
					<tr>
						<td class="tg-0pky right">Paper</td>
						<td class="tg-c3ow left" style="background: #FF8360">\(0\)</td>
						<td class="tg-c3ow">\(1\)</td>
						<td class="tg-baqh right">\(2\)</td>
					</tr>
					<tr>
						<td class="tg-0lax right">Rock</td>
						<td class="tg-baqh left bottom" style="background: #FF8360">\(-1\)</td>
						<td class="tg-baqh bottom">\(0\)</td>
						<td class="tg-baqh right bottom">\(1\)</td>
					</tr>
				</tbody>
				</table>
				<p>
					<b>Figure 2</b>: Payoff matrix for a rock, paper, scissors game with a solution.
				</p>
			</div>
		</div>
		<p class="indent">
			Up until now, we have only considered what is called <em>pure strategies</em>. 
			That is, choosing exactly one strategy and sticking to it. However, what if 
			our strategy was chosen randomly from some distribution? This is called 
			<em>mixed strategies</em>. If the payoff matrix \(P\) is of dimension \(n \times m\), 
			then Robert’s probability distribution is a column vector \(\boldsymbol{p} = (p_1, \dots, p_n)\), 
			from which he will choose a strategy \(i\) with probability \(p_i\). 
			Similarly, Charles’ probability distribution is a column vector 
			\(\boldsymbol{q} = (q_1, \dots, q_m)\), from which he will choose a strategy 
			\(j\) with probability \(q_j\). Thus, we have \[\begin{aligned} \mathcal{O}_R &= 
			\max_\boldsymbol{p} \min_\boldsymbol{q} \boldsymbol{p}^T P \boldsymbol{q}, \\ 
			\mathcal{O}_C &= \min_\boldsymbol{q} \max_\boldsymbol{p} \boldsymbol{p}^T P \boldsymbol{q}.\end{aligned}\]
		</p>
		<p class="indent">
			Now, <a href="https://en.wikipedia.org/wiki/John_von_Neumann">John von Neumann</a> 
			found the following theorem in his early work in game theory. In simple terms, it says 
			that every two-person zero-sum game has a solution when using mixed strategies.
		</p>
		<div class="theorem-container">
			<div class="theorem">
				<p>
					<b>Theorem 1</b>: For any two-person zero-sum game specified by a payoff
					matrix \(P\), \[\max_\boldsymbol{p} \min_\boldsymbol{q} \boldsymbol{p}^T P \boldsymbol{q} = 
					\min_\boldsymbol{q} \max_\boldsymbol{p} \boldsymbol{p}^T P \boldsymbol{q}.\]	
				</p>
			</div>
		</div>
		<p class="indent">
			Shortly after, <a href="https://en.wikipedia.org/wiki/Lynn_Harold_Loomis">Lynn Loomis</a> 
			found that von Neumann’s theorem allowed for less strict 
			strategies of play. It says in simple terms that for a two-person zero-sum game, 
			having one player use a mixed strategy and the other use a pure strategy is 
			sufficient for a solution to the game.
		</p>
		<div class="theorem-container" style="margin-bottom: 15px;">
			<div class="theorem">
				<p>
					<b>Theorem 2</b>: For any two-person zero-sum game specified by a payoff
					matrix \(P\), \[\max_\boldsymbol{p} \min_j \boldsymbol{p}^T P \boldsymbol{e}_j = 
					\min_\boldsymbol{q} \max_i \boldsymbol{e}_i^T P \boldsymbol{q}.\]	
				</p>
			</div>
		</div>
		<h2>Randomized Algorithms</h2>
		<p class="indent">
			Now, we have the necessary foundations of game theory set in place to start talking 
			about its profound influence on randomized algorithms. First, I should note that a 
			randomized algorithm can be modeled by a 
			<a href="https://en.wikipedia.org/wiki/Probabilistic_Turing_machine">probabilistic Turing machine</a>. 
			That is, a Turing machine that also takes as input a tape of uniformly random bits. 
			Or, it is a probability distribution on deterministic algorithms. Remember that, 
			we’ll come back to this idea. 
		</p>
		<p class="indent">
			Why might we prefer a randomized algorithm? It is easy for an adversary to devise 
			an input such that a deterministic algorithm performs in its worst-case. But, it will be 
			difficult for an adversary to foil a randomized algorithm, as the steps of execution, and thus performance, 
			will differ with each execution. When we analyze randomized algorithm performance, 
			we usually want to bound its expected performance. Moreover, we usually show that it 
			achieves this bound with high probability. Specifically, for a problem of size \(n\), 
			we say that some property is true with high probability if it is true with probability 
			\(1-1/n^k\) for some constant \(k \geq 1\).
		</p>
		<p class="indent">
			Now, <a href="https://en.wikipedia.org/wiki/Andrew_Yao">Andrew Yao</a> took the 
			above ideas from Loomis and von Neumann and applied it to randomized algorithms 
			in what is known famously as <a href="https://en.wikipedia.org/wiki/Yao%27s_principle">Yao’s minimax principle</a>. 
			The idea is this. Let the columns represent all deterministic algorithms that give a correct solution to the 
			problem. The algorithm designer is selecting these strategies. Then, view the rows 
			as the set of all possible inputs of fixed size. The adversary is selecting these 
			inputs as their strategy to the game. For an input \(x_i\) and an algorithm \(A_j\), the 
			performance of \(A_j\) on input \(x_j\) is \(T(x_i, A_j)\), which is component 
			\(P_{i,j}\) of the payoff matrix. I say “performance” generally, because we may be 
			measuring the complexity of the algorithm with respect to time, space, communication cost, etc. See 
			<b>Figure 3</b> for the pictorial representation of the game.
		</p>
		<div class="figure-container">
			<div class="figure">
				<table class="tg">
				<tbody>
					<tr>
						<td class="tg-sxqf center" style="border: none;"></td>
						<td class="tg-c3ow center" style="border: none;"></td>
						<td class="tg-c3ow center" colspan="3">Algorithm Designer</td>
					</tr>
					<tr>
						<td class="tg-0pky center" style="border: none;"></td>
						<td class="tg-c3ow center" style="border: none;"></td>
						<td class="tg-c3ow center bottom">\(A_1\)</td>
						<td class="tg-c3ow center bottom">\(\dots\)</td>
						<td class="tg-baqh center bottom">\(A_m\)</td>
					</tr>
					<tr>
						<td class="tg-0pky center" rowspan="3" style="transform: rotate(270deg); width: 30px;">Input Designer</td>
						<td class="tg-0pky center right">\(x_1\)</td>
						<td class="tg-c3ow center left top">\(T(x_1, A_1)\)</td>
						<td class="tg-c3ow center top">\(\dots\)</td>
						<td class="tg-baqh center top right">\(T(x_1, A_m)\)</td>
					</tr>
					<tr>
						<td class="tg-0pky center right">\(\vdots\)</td>
						<td class="tg-c3ow center left">\(\vdots\)</td>
						<td class="tg-c3ow center">\(\ddots\)</td>
						<td class="tg-baqh center right">\(\vdots\)</td>
					</tr>
					<tr>
						<td class="tg-0lax center right">\(x_n\)</td>
						<td class="tg-baqh center bottom left">\(T(x_n, A_1)\)</td>
						<td class="tg-baqh center bottom">\(\dots\)</td>
						<td class="tg-baqh center bottom right">\(T(x_n, A_m)\)</td>
					</tr>
				</tbody>
				</table>
				<p>
					<b>Figure 3</b>: Payoff matrix for a game between an algorithm designer and
					input designer, where the components are the performance of the algorithm chosen
					on the input chosen.
				</p>
			</div>
		</div>
		<p class="indent">
			As before, the column player, the algorithm designer, wants to minimize the payoff. Likewise, 
			the row player, the input adversary, wants to maximize the payoff. The optimal pure strategy 
			for the algorithm designer is the optimal deterministic algorithm. An optimal pure strategy 
			for the input adversary is a specific input. A mixed strategy for the algorithm designer is a 
			<a href="https://en.wikipedia.org/wiki/Las_Vegas_algorithm">Las Vegas randomized algorithm</a>, 
			or a randomized algorithm that always produces a correct answer. Remember, we require the 
			columns to be deterministic algorithms that must provide a correct solution. A mixed strategy 
			for the input adversary is a distribution on the inputs.
		</p>
		<p class="indent">
			Listen up! This is the climax of the article and realization of Yao! Following the results 
			of von Neumann and Loomis above, we find that the expected performance of the best 
			deterministic algorithm over the worst distribution of inputs is less or equal than the 
			expected performance over the best distribution of all deterministic algorithms on the worst 
			input. Yao’s minimax principle is mathematically defined in the following theorem.
		</p>
		<div class="theorem-container">
			<div class="theorem">
				<p>
					<b>Theorem 3</b>: Let \(\Pi\) be a problem with a finite set \(\mathcal{X}\) of 
					fixed size input instances, and a finite set of deterministic algorithms \(\mathcal{A}\) 
					that give a correct result to \(\Pi\). For input \(X \in \mathcal{X}\) and algorithm 
					\(A \in \mathcal{A}\), let \(T(X, A)\) denote the performance of algorithm \(A\) on input \(X\).
					For probability distributions \(\boldsymbol{p}\) over \(\mathcal{X}\) and \(\boldsymbol{q}\) 
					over \(\mathcal{A}\), let \(X_\boldsymbol{p}\) denote a random input chosen according to 
					\(\boldsymbol{p}\) and \(A_\boldsymbol{q}\) dentoe a random algorithm chosen according to 
					\(\boldsymbol{q}\). Then, for all distributions \(\boldsymbol{p}\) over \(\mathcal{X}\) 
					and \(\boldsymbol{q}\) over \(\mathcal{A}\), \[\min_{A \in \mathcal{A}} \mathbb{E}
					\left[ T(X_\boldsymbol{p}, A) \right] \leq \max_{X \in \mathcal{X}} \mathbb{E} 
					\left[ T(X, A_\boldsymbol{q}) \right].\]
				</p>
			</div>
		</div>
		<p class="indent">
			The RHS is the expected performance of our randomized algorithm on the worst possible input.
			Thus, to lower bound this complexity, we can choose a distribution \(\boldsymbol{p}\) over the input space 
			and prove a lower bound on the expected running time of deterministic algorithms for that distribution. 
			One mistake I often made when attempting this lower bounding technique in the beginning is not realizing 
			that Yao's minimax principle implies that the best deterministic algorithm "knows" the distribution 
			of inputs with which it is being tested on.	
		</p>
		<h2>Applying Yao's Minimax Principle</h2>
		<p class="indent">
			In this final section, I give an example of applying Yao's minimax principle for finding a lower 
			bound of a randomized algorithm's performance. In this example, we will be bounding its expected 
			running time.	First, we note that the definition of a <a href="https://mathworld.wolfram.com/PerfectMatching.html">perfect matching</a>
			on a graph \(G = (V, E)\) with \(|V| = n\), where \(n\) is even, is a set of \(n/2\) edges, no two of which 
			share a common vertex. 
		</p>
		<p class="indent">
			<b>Problem 1</b>: Consider a randomized algorithm that takes an \(n\)-vertex graph as input 
			and correctly determines if the graph has a perfect matching. At each step, the algorithm may ask a question 
			of the form "Is there an edge between vertex \(i\) and vertex \(j\)?" The cost of asking the question is 1, and 
			this is the only operation with a cost. The complexity \(C(n)\) of the algorithm is the maximum over all 
			\(n\)-vertex  graphs \(G\), of the expected number of questions asked when the input graph is \(G\). We want 
			to prove \(C(n) = \Omega(n^2)\).
		</p>
		<p class="indent">
			<em><b>Proof</b>.</em> To use Yao's minimax principle, we want to construct an input distribution over all \(n\)-vertex 
			graphs such that any deterministic algorithm asks, on average, \(\Omega(n^2)\) questions to determine if the 
			input graph has a perfect matching. Let \(P\) be the set of all graphs with perfect matchings on \(n\) vertices. Let 
			\(Q\) be the set of all graphs with matchings of size \(n/2 - 1\) on \(n\) vertices. We will create the input 
			distribution so that we sample a graph from \(P\) with probability \(1/2\) and sample from \(Q\) 
			with probability \(1/2\). 
		</p>
		<p class="indent">
			Remember, a deterministic algorithm will know what this input distribution is, so 
			sampling strictly from one of these sets with probability \(1\) will allow the deterministic algorithm to solve 
			the problem trivially. But, now that the deterministic algorithm does not immediately know the solution, 
			it will deterministically ask if a fixed vertex, say \(v_1\), is connected to any other vertex until it finds one. On average, 
			this costs at least \(n/2\) questions. If we condition on the event that \(v_1\) is connected to another vertex, 
			say \(v_2\), then the deterministic algorithm will check if a vertex, say \(v_3\), which is different from 
			\(v_1\) and \(v_2\), is connected to any of the remaining vertices. Remember, this is a deterministic algorithm, 
			so it will have some predefined non-random logic for the order of selecting these vertices. This second step will 
			take an average of at least \((n - 2) / 2\) questions. In general, the \(k\)th step takes, on average, 
			at least \((n - 2k) / 2\) questions, conditioned on the event that \(k\) pairs of vertices have already been 
			successfully matched.  
		</p>
		<p class="indent">
			Now, if we condition on the event that the input graph was sampled from \(P\), then on average, 
			it will take at least \[ \sum_{k = 0}^{\frac{n-2}{2}}\frac{n-2k}{2} = \Omega(n^2) \] questions. Since we sampled 
			from \(P\) with probability \(1/2\), then it also takes an average \(C(n) = \Omega(n^2)\) questions. 
			<span class="qed">\[\tag*{$\blacksquare$}\]</span>
		</p>
		<h2>References</h2>
		<p>
			Bonanno, G. (2018). <em>Game Theory: Volume 1: Basic Concepts</em>. North Charleston, SC: Createspace Independent 
			Publishing Platform.
		</p>
		<p>
			Motwani, R., & Raghavan, P. (1995). <em>Randomized Algorithms</em>. Cambridge, England: Cambridge University Press.
		</p>
	</article>
</body>
<hr>
<footer>
<a href="/" style="margin-right: 30px; font-variant: small-caps;">Home</a>
<a href="/blog/" style="margin-left: 0 30px; font-variant: small-caps;">Blog</a>
<a href="/about/" style="margin-left: 30px; font-variant: small-caps;">About</a>
</footer>
</html>
